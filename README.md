# SUPABASE SCRIPT REFERENCE

```
-- Custom types for company roles and permissions
CREATE TYPE public.company_role AS ENUM ('owner', 'admin', 'hr', 'social', 'member');
CREATE TYPE public.company_permission AS ENUM (
  'company.edit',
  'member.invite',
  'member.remove',
  'member.edit_role',
  'job.create',
  'job.edit',
  'job.delete',
  'application.view',
  'application.manage'
);

-- Personal profiles table
CREATE TABLE public.personal_profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  username TEXT UNIQUE,
  full_name TEXT,
  email TEXT UNIQUE,
  avatar_url TEXT,
  website TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE,
  
  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);

-- Companies table
CREATE TABLE public.companies (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  username TEXT UNIQUE NOT NULL,
  company_name TEXT NOT NULL,
  description TEXT,
  logo_url TEXT,
  website TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE,
  created_by UUID REFERENCES auth.users NOT NULL,
  
  CONSTRAINT company_username_length CHECK (char_length(username) >= 3)
);

-- Company members table (connects users to companies with roles)
CREATE TABLE public.company_members (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  company_id BIGINT REFERENCES public.companies ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role company_role NOT NULL DEFAULT 'member'::public.company_role,
  invited_by UUID REFERENCES auth.users,
  invited_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  joined_at TIMESTAMP WITH TIME ZONE,
  
  UNIQUE(company_id, user_id)
);

-- Company member invitations table
CREATE TABLE public.company_invitations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  company_id BIGINT REFERENCES public.companies ON DELETE CASCADE NOT NULL,
  email TEXT NOT NULL,
  role company_role NOT NULL DEFAULT 'member'::public.company_role,
  token TEXT UNIQUE NOT NULL,
  invited_by UUID REFERENCES auth.users NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT (timezone('utc'::text, now()) + interval '7 days') NOT NULL,
  
  UNIQUE(company_id, email)
);

-- Role permissions table
CREATE TABLE public.role_permissions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role company_role NOT NULL,
  permission company_permission NOT NULL,
  
  UNIQUE(role, permission)
);

-- Insert default role permissions
INSERT INTO public.role_permissions (role, permission) VALUES
  ('owner', 'company.edit'),
  ('owner', 'member.invite'),
  ('owner', 'member.remove'),
  ('owner', 'member.edit_role'),
  ('owner', 'job.create'),
  ('owner', 'job.edit'),
  ('owner', 'job.delete'),
  ('owner', 'application.view'),
  ('owner', 'application.manage'),
  
  ('admin', 'member.invite'),
  ('admin', 'member.remove'),
  ('admin', 'member.edit_role'),
  ('admin', 'job.create'),
  ('admin', 'job.edit'),
  ('admin', 'job.delete'),
  ('admin', 'application.view'),
  ('admin', 'application.manage'),
  
  ('hr', 'member.invite'),
  ('hr', 'job.create'),
  ('hr', 'job.edit'),
  ('hr', 'application.view'),
  ('hr', 'application.manage'),
  
  ('social', 'job.create'),
  ('social', 'job.edit'),
  
  ('member', 'application.view');

-- Function to authorize company permissions
CREATE FUNCTION public.authorize_company(
  requested_permission company_permission,
  company_id BIGINT,
  user_id UUID
)
RETURNS BOOLEAN AS $$
DECLARE
  has_permission BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1
    FROM public.company_members
    JOIN public.role_permissions ON company_members.role = role_permissions.role
    WHERE 
      company_members.company_id = authorize_company.company_id AND
      company_members.user_id = authorize_company.user_id AND
      role_permissions.permission = authorize_company.requested_permission
  ) INTO has_permission;
  
  RETURN has_permission;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user is a member of a company
CREATE FUNCTION public.is_company_member(
  company_id BIGINT,
  user_id UUID
)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.company_members
    WHERE company_id = is_company_member.company_id
      AND user_id = is_company_member.user_id
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Enable Row Level Security
ALTER TABLE public.personal_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.company_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.company_invitations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;

-- RLS policies for personal_profiles
CREATE POLICY "Users can view any personal profile" ON public.personal_profiles
  FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Users can insert their own personal profile" ON public.personal_profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own personal profile" ON public.personal_profiles
  FOR UPDATE USING (auth.uid() = id);

-- RLS policies for companies
CREATE POLICY "Anyone can view companies" ON public.companies
  FOR SELECT USING (true);

CREATE POLICY "Users can create companies" ON public.companies
  FOR INSERT WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Company owners and admins can update company" ON public.companies
  FOR UPDATE USING (
    authorize_company('company.edit', id, auth.uid())
  );

-- RLS policies for company_members
CREATE POLICY "Anyone can view company members" ON public.company_members
  FOR SELECT USING (true);

CREATE POLICY "Company owners and admins can insert members" ON public.company_members
  FOR INSERT WITH CHECK (
    authorize_company('member.invite', company_id, auth.uid())
  );

CREATE POLICY "Company owners and admins can update members" ON public.company_members
  FOR UPDATE USING (
    authorize_company('member.edit_role', company_id, auth.uid())
  );

CREATE POLICY "Company owners and admins can delete members" ON public.company_members
  FOR DELETE USING (
    authorize_company('member.remove', company_id, auth.uid())
  );

-- RLS policies for company_invitations
CREATE POLICY "Company members can view invitations" ON public.company_invitations
  FOR SELECT USING (
    is_company_member(company_id, auth.uid())
  );

CREATE POLICY "Users with invite permission can create invitations" ON public.company_invitations
  FOR INSERT WITH CHECK (
    authorize_company('member.invite', company_id, auth.uid())
  );

CREATE POLICY "Users with invite permission can delete invitations" ON public.company_invitations
  FOR DELETE USING (
    authorize_company('member.invite', company_id, auth.uid())
  );

-- RLS policies for role_permissions
CREATE POLICY "Everyone can view role permissions" ON public.role_permissions
  FOR SELECT USING (true);

-- Trigger function to handle new user registration
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  user_type TEXT;
BEGIN
  -- Get the user type from metadata
  user_type := NEW.raw_user_meta_data->>'user_type';
  
  -- Handle personal profile
  IF user_type = 'personal' THEN
    INSERT INTO public.personal_profiles (
      id, 
      email,
      full_name, 
      avatar_url
    )
    VALUES (
      NEW.id,
      NEW.email,
      NEW.raw_user_meta_data->>'full_name',
      NEW.raw_user_meta_data->>'avatar_url'
    );
  END IF;
  
  -- For company accounts, we'll handle company creation separately
  -- This will happen when the user enters company details after registration
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for when a new user signs up
CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function to handle company invitations when a user signs up
CREATE OR REPLACE FUNCTION public.handle_company_invitation()
RETURNS TRIGGER
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  invitation RECORD;
BEGIN
  -- Check if the new user has any pending invitations
  FOR invitation IN 
    SELECT * FROM public.company_invitations 
    WHERE email = NEW.email 
      AND expires_at > now()
  LOOP
    -- Add the user to the company with the invited role
    INSERT INTO public.company_members (
      company_id,
      user_id,
      role,
      invited_by,
      invited_at,
      joined_at
    ) VALUES (
      invitation.company_id,
      NEW.id,
      invitation.role,
      invitation.invited_by,
      invitation.created_at,
      now()
    )
    ON CONFLICT (company_id, user_id) DO NOTHING;
  
    -- Delete the invitation
    DELETE FROM public.company_invitations 
    WHERE id = invitation.id;
  END LOOP;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for handling company invitations
CREATE OR REPLACE TRIGGER on_auth_user_created_check_invitations
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_company_invitation();

-- Function to create a company and assign owner role
CREATE OR REPLACE FUNCTION public.create_company(
  company_username TEXT,
  company_name TEXT,
  description TEXT DEFAULT NULL,
  website TEXT DEFAULT NULL
)
RETURNS BIGINT
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  new_company_id BIGINT;
BEGIN
  -- Check if username is already taken
  IF EXISTS (SELECT 1 FROM public.companies WHERE username = company_username) THEN
    RAISE EXCEPTION 'Company username is already taken';
  END IF;

  -- Insert the new company
  INSERT INTO public.companies (
    username,
    company_name,
    description,
    website,
    created_by
  ) VALUES (
    company_username,
    company_name,
    description,
    website,
    auth.uid()
  ) RETURNING id INTO new_company_id;
  
  -- Add the current user as the owner
  INSERT INTO public.company_members (
    company_id,
    user_id,
    role,
    joined_at
  ) VALUES (
    new_company_id,
    auth.uid(),
    'owner',
    now()
  );
  
  RETURN new_company_id;
END;
$$ LANGUAGE plpgsql;

-- Function to create an invitation to join a company
CREATE OR REPLACE FUNCTION public.invite_to_company(
  company_id BIGINT,
  email TEXT,
  role company_role DEFAULT 'member'
)
RETURNS TEXT
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  token TEXT;
BEGIN
  -- Check if the user has permission to invite
  IF NOT authorize_company('member.invite', company_id, auth.uid()) THEN
    RAISE EXCEPTION 'You do not have permission to invite members to this company';
  END IF;
  
  -- Generate a random token
  token := encode(gen_random_bytes(20), 'hex');
  
  -- Create the invitation
  INSERT INTO public.company_invitations (
    company_id,
    email,
    role,
    token,
    invited_by
  ) VALUES (
    company_id,
    email,
    role,
    token,
    auth.uid()
  ) ON CONFLICT (company_id, email) 
  DO UPDATE SET 
    role = EXCLUDED.role,
    token = EXCLUDED.token,
    invited_by = EXCLUDED.invited_by,
    created_at = now(),
    expires_at = now() + interval '7 days';
  
  RETURN token;
END;
$$ LANGUAGE plpgsql;

-- Set up Storage for avatar and logo uploads
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true)
ON CONFLICT DO NOTHING;

INSERT INTO storage.buckets (id, name, public)
VALUES ('company_logos', 'company_logos', true)
ON CONFLICT DO NOTHING;

-- Create policies for storage
CREATE POLICY "Anyone can view avatars" ON storage.objects
  FOR SELECT USING (bucket_id = 'avatars');

CREATE POLICY "Authenticated users can upload avatars" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'avatars' AND
    auth.role() = 'authenticated'
  );

CREATE POLICY "Users can update their own avatar" ON storage.objects
  FOR UPDATE USING (
    bucket_id = 'avatars' AND
    auth.uid()::text = (storage.foldername(name))[1]
  );

CREATE POLICY "Anyone can view company logos" ON storage.objects
  FOR SELECT USING (bucket_id = 'company_logos');

CREATE POLICY "Company owners and admins can upload logos" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'company_logos' AND
    auth.role() = 'authenticated'
  );

CREATE POLICY "Company owners and admins can update logos" ON storage.objects
  FOR UPDATE USING (
    bucket_id = 'company_logos' AND
    EXISTS (
      SELECT 1 FROM public.companies
      WHERE id::text = (storage.foldername(name))[1]
      AND authorize_company('company.edit', id, auth.uid())
    )
  );
```
