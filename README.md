-- Custom types for company roles and permissions

CREATE TYPE public.company_role AS ENUM ('owner','admin','hr','social','member');

CREATE TYPE public.company_permission AS ENUM (

'company.edit',

'member.invite',

'member.remove',

'member.edit_role',

'job.create',

'job.edit',

'job.delete',

'application.view',

'application.manage'

);

-- User types table to track whether a user is a personal or company account

CREATETABLE public.user_types (

  id UUID REFERENCES auth.users ON DELETE CASCADE NOTNULLPRIMARY KEY,

  user_type TEXT NOTNULLCHECK(user_type IN('personal','company')),

  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())NOTNULL

);

-- Personal profiles table

CREATETABLE public.personal_profiles (

  id UUID REFERENCES auth.users ON DELETE CASCADE NOTNULLPRIMARY KEY,

  username TEXT UNIQUE,

  full_name TEXT,

  email TEXT UNIQUE,

  avatar_url TEXT,

  website TEXT,

  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())NOTNULL,

  updated_at TIMESTAMP WITH TIME ZONE,

CONSTRAINT username_length CHECK(char_length(username)>=3)

);

-- Companies table

CREATETABLE public.companies (

  id BIGINT GENERATED BY DEFAULTAS IDENTITY PRIMARY KEY,

  username TEXT UNIQUENOTNULL,

  company_name TEXT NOTNULL,

  description TEXT,

  logo_url TEXT,

  website TEXT,

  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())NOTNULL,

  updated_at TIMESTAMP WITH TIME ZONE,

  created_by UUID REFERENCES auth.users NOTNULL,

CONSTRAINT company_username_length CHECK(char_length(username)>=3)

);

-- Company members table (connects users to companies with roles)

CREATETABLE public.company_members (

  id BIGINT GENERATED BY DEFAULTAS IDENTITY PRIMARY KEY,

  company_id BIGINT REFERENCES public.companies ON DELETE CASCADE NOTNULL,

  user_id UUID REFERENCES auth.users ON DELETE CASCADE NOTNULL,

  role company_role NOTNULLDEFAULT'member'::public.company_role,

  invited_by UUID REFERENCES auth.users,

  invited_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),

  joined_at TIMESTAMP WITH TIME ZONE,

UNIQUE(company_id, user_id)

);

-- Company member invitations table

CREATETABLE public.company_invitations (

  id BIGINT GENERATED BY DEFAULTAS IDENTITY PRIMARY KEY,

  company_id BIGINT REFERENCES public.companies ON DELETE CASCADE NOTNULL,

  email TEXT NOTNULL,

  role company_role NOTNULLDEFAULT'member'::public.company_role,

  token TEXT UNIQUENOTNULL,

  invited_by UUID REFERENCES auth.users NOTNULL,

  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())NOTNULL,

  expires_at TIMESTAMP WITH TIME ZONE DEFAULT(timezone('utc'::text, now())+ interval '7 days')NOTNULL,

UNIQUE(company_id, email)

);

-- Role permissions table

CREATETABLE public.role_permissions (

  id BIGINT GENERATED BY DEFAULTAS IDENTITY PRIMARY KEY,

  role company_role NOTNULL,

  permission company_permission NOTNULL,

UNIQUE(role, permission)

);

-- Insert default role permissions

INSERT INTO public.role_permissions (role, permission) VALUES

('owner','company.edit'),

('owner','member.invite'),

('owner','member.remove'),

('owner','member.edit_role'),

('owner','job.create'),

('owner','job.edit'),

('owner','job.delete'),

('owner','application.view'),

('owner','application.manage'),

('admin','member.invite'),

('admin','member.remove'),

('admin','member.edit_role'),

('admin','job.create'),

('admin','job.edit'),

('admin','job.delete'),

('admin','application.view'),

('admin','application.manage'),

('hr','member.invite'),

('hr','job.create'),

('hr','job.edit'),

('hr','application.view'),

('hr','application.manage'),

('social','job.create'),

('social','job.edit'),

('member','application.view');

-- Function to authorize company permissions

CREATEOR REPLACE FUNCTION public.authorize_company(

  requested_permission company_permission,

  company_id BIGINT,

  user_id UUID

)

RETURNS BOOLEAN AS$$

DECLARE

  has_permission BOOLEAN;

BEGIN

SELECT EXISTS (

SELECT1

FROM public.company_members

JOIN public.role_permissions ON company_members.role = role_permissions.role

WHERE

    company_members.company_id = authorize_company.company_id AND

    company_members.user_id = authorize_company.user_id AND

    role_permissions.permission = authorize_company.requested_permission

)INTO has_permission;

  RETURN has_permission;

END;

$$
LANGUAGE plpgsql SECURITY DEFINER;


-- Function to check if user is a member of a company

CREATEOR REPLACE FUNCTION public.is_company_member(

  company_id BIGINT,

  user_id UUID

)

RETURNS BOOLEAN AS
$$

BEGIN

  RETURN EXISTS (

SELECT1FROM public.company_members

WHERE company_id = is_company_member.company_id

AND user_id = is_company_member.user_id

);

END;

$$
LANGUAGE plpgsql SECURITY DEFINER;


-- Enable Row Level Security

ALTER TABLE public.user_types ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.personal_profiles ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.company_members ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.company_invitations ENABLE ROW LEVEL SECURITY;

ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;


-- RLS policies for user_types

CREATE POLICY "Users can view their own user type" ON public.user_types

FORSELECTUSING(auth.uid()= id);


CREATE POLICY "Users can insert their own user type" ON public.user_types

FOR INSERT WITHCHECK(auth.uid()= id);


-- RLS policies for personal_profiles

CREATE POLICY "Users can view any personal profile" ON public.personal_profiles

FORSELECTUSING(auth.role()='authenticated');


CREATE POLICY "Users can insert their own personal profile" ON public.personal_profiles

FOR INSERT WITHCHECK(auth.uid()= id);


CREATE POLICY "Users can update own personal profile" ON public.personal_profiles

FOR UPDATE USING(auth.uid()= id);


-- RLS policies for companies

CREATE POLICY "Anyone can view companies" ON public.companies

FORSELECTUSING(true);


CREATE POLICY "Users can create companies" ON public.companies

FOR INSERT WITHCHECK(auth.uid()= created_by);


CREATE POLICY "Company owners and admins can update company" ON public.companies

FOR UPDATE USING(

    authorize_company('company.edit', id, auth.uid())

);


-- RLS policies for company_members

CREATE POLICY "Anyone can view company members" ON public.company_members

FORSELECTUSING(true);


CREATE POLICY "Company owners and admins can insert members" ON public.company_members

FOR INSERT WITHCHECK(

    authorize_company('member.invite', company_id, auth.uid())

);


CREATE POLICY "Company owners and admins can update members" ON public.company_members

FOR UPDATE USING(

    authorize_company('member.edit_role', company_id, auth.uid())

);


CREATE POLICY "Company owners and admins can delete members" ON public.company_members

FOR DELETE USING(

    authorize_company('member.remove', company_id, auth.uid())

);


-- RLS policies for company_invitations

CREATE POLICY "Company members can view invitations" ON public.company_invitations

FORSELECTUSING(

    is_company_member(company_id, auth.uid())

);


CREATE POLICY "Users with invite permission can create invitations" ON public.company_invitations

FOR INSERT WITHCHECK(

    authorize_company('member.invite', company_id, auth.uid())

);


CREATE POLICY "Users with invite permission can delete invitations" ON public.company_invitations

FOR DELETE USING(

    authorize_company('member.invite', company_id, auth.uid())

);


-- RLS policies for role_permissions

CREATE POLICY "Everyone can view role permissions" ON public.role_permissions

FORSELECTUSING(true);


-- Function to handle new user registration (for Google OAuth)

CREATEOR REPLACE FUNCTION public.handle_new_google_user()

RETURNS TRIGGER

SECURITY DEFINER SET search_path = public

AS
$$

BEGIN

-- Insert into user_types table first

-- Note: Initially user type will be 'personal' by default

-- User can change to 'company' later if needed

  INSERT INTO public.user_types (id, user_type)

  VALUES (NEW.id,'personal');

-- Insert user into personal profiles

  INSERT INTO public.personal_profiles (

    id,

    email,

    full_name,

    avatar_url

)

  VALUES (

    NEW.id,

    NEW.email,

    NEW.raw_user_meta_data->>'full_name',

    NEW.raw_user_meta_data->>'avatar_url'

);

  RETURN NEW;

END;

$$
LANGUAGE plpgsql;


-- Trigger for when a new user signs up with Google OAuth

CREATEOR REPLACE TRIGGER on_auth_user_created

  AFTER INSERT ON auth.users

FOR EACH ROW EXECUTE FUNCTION public.handle_new_google_user();


-- Function to handle user type changes from personal to company

CREATEOR REPLACE FUNCTION public.handle_user_type_change()

RETURNS TRIGGER

SECURITY DEFINER SET search_path = public

AS
$$

BEGIN

-- If user type changed from personal to company, we need to check if they supplied company info

  IF NEW.user_type ='company'AND OLD.user_type ='personal'THEN

-- If there's metadata with company details, create the company

    IF EXISTS (

SELECT1FROM auth.users

WHERE id = NEW.id

AND raw_user_meta_data->>'company_name'ISNOTNULL

AND raw_user_meta_data->>'company_username'ISNOTNULL

)THEN

-- Create the company

    DECLARE

    company_name TEXT;

    company_username TEXT;

    company_website TEXT;

    new_company_id BIGINT;

    BEGIN

-- Get company details from user metadata

SELECT

    raw_user_meta_data->>'company_name',

    raw_user_meta_data->>'company_username',

    raw_user_meta_data->>'company_website'

INTO company_name, company_username, company_website

FROM auth.users

WHERE id = NEW.id;

-- Check if company username is already taken

    IF EXISTS (SELECT1FROM public.companies WHERE username = company_username)THEN

    RAISE EXCEPTION 'Company username is already taken: %', company_username;

END IF;

-- Create company

    INSERT INTO public.companies (

    username,

    company_name,

    description,

    website,

    created_by

) VALUES (

    company_username,

    company_name,

NULL,

    company_website,

    NEW.id

)RETURNING id INTO new_company_id;

-- Make user an owner of the company

    INSERT INTO public.company_members (

    company_id,

    user_id,

    role,

    joined_at

) VALUES (

    new_company_id,

    NEW.id,

'owner',

    NOW()

);

END;

END IF;

END IF;

  RETURN NEW;

END;

$$
LANGUAGE plpgsql;


-- Trigger for when a user type changes

CREATEOR REPLACE TRIGGER on_user_type_change

  AFTER UPDATE ON public.user_types

FOR EACH ROW EXECUTE FUNCTION public.handle_user_type_change();


-- Function to handle company invitations when a user signs up

CREATEOR REPLACE FUNCTION public.handle_company_invitation()

RETURNS TRIGGER

SECURITY DEFINER SET search_path = public

AS
$$

DECLARE

  invitation RECORD;

BEGIN

-- Check if the new user has any pending invitations

FOR invitation IN

SELECT*FROM public.company_invitations

WHERE email = NEW.email

AND expires_at > now()

  LOOP

-- Add the user to the company with the invited role

    INSERT INTO public.company_members (

    company_id,

    user_id,

    role,

    invited_by,

    invited_at,

    joined_at

) VALUES (

    invitation.company_id,

    NEW.id,

    invitation.role,

    invitation.invited_by,

    invitation.created_at,

    now()

)

ON CONFLICT (company_id, user_id)DO NOTHING;

-- Delete the invitation

    DELETE FROM public.company_invitations

WHERE id = invitation.id;

END LOOP;

  RETURN NEW;

END;

$$
LANGUAGE plpgsql;


-- Trigger for handling company invitations

CREATEOR REPLACE TRIGGER on_auth_user_created_check_invitations

  AFTER INSERT ON auth.users

FOR EACH ROW EXECUTE FUNCTION public.handle_company_invitation();


-- Function to create a company and assign owner role

CREATEOR REPLACE FUNCTION public.create_company(

  company_username TEXT,

  company_name TEXT,

  description TEXT DEFAULTNULL,

  website TEXT DEFAULTNULL

)

RETURNS BIGINT

SECURITY DEFINER SET search_path = public

AS
$$

DECLARE

  new_company_id BIGINT;

BEGIN

-- Check if username is already taken

  IF EXISTS (SELECT1FROM public.companies WHERE username = company_username)THEN

    RAISE EXCEPTION 'Company username is already taken';

END IF;

-- Insert the new company

  INSERT INTO public.companies (

    username,

    company_name,

    description,

    website,

    created_by

) VALUES (

    company_username,

    company_name,

    description,

    website,

    auth.uid()

)RETURNING id INTO new_company_id;

-- Add the current user as the owner

  INSERT INTO public.company_members (

    company_id,

    user_id,

    role,

    joined_at

) VALUES (

    new_company_id,

    auth.uid(),

'owner',

    now()

);

-- Update user type to company if it was personal

  UPDATE public.user_types

  SET user_type ='company'

WHERE id = auth.uid()AND user_type ='personal';

  RETURN new_company_id;

END;

$$
LANGUAGE plpgsql;


-- Function to create an invitation to join a company

CREATEOR REPLACE FUNCTION public.invite_to_company(

  company_id BIGINT,

  email TEXT,

  role company_role DEFAULT'member'

)

RETURNS TEXT

SECURITY DEFINER SET search_path = public

AS
$$

DECLARE

  token TEXT;

BEGIN

-- Check if the user has permission to invite

  IF NOT authorize_company('member.invite', company_id, auth.uid())THEN

    RAISE EXCEPTION 'You do not have permission to invite members to this company';

END IF;

-- Generate a random token

  token := encode(gen_random_bytes(20),'hex');

-- Create the invitation

  INSERT INTO public.company_invitations (

    company_id,

    email,

    role,

    token,

    invited_by

) VALUES (

    company_id,

    email,

    role,

    token,

    auth.uid()

)ON CONFLICT (company_id, email)

DO UPDATE SET

    role = EXCLUDED.role,

    token = EXCLUDED.token,

    invited_by = EXCLUDED.invited_by,

    created_at = now(),

    expires_at = now()+ interval '7 days';

  RETURN token;

END;

$$
LANGUAGE plpgsql;


-- Function to change user type from personal to company

CREATEOR REPLACE FUNCTION public.change_to_company_user(

  company_name TEXT,

  company_username TEXT,

  company_website TEXT DEFAULTNULL

)

RETURNS BIGINT

SECURITY DEFINER SET search_path = public

AS
$$

DECLARE

  user_type_val TEXT;

  new_company_id BIGINT;

BEGIN

-- Get current user type

SELECT user_type INTO user_type_val

FROM public.user_types

WHERE id = auth.uid();

-- Check if user is already a company user

  IF user_type_val ='company'THEN

    RAISE EXCEPTION 'User is already a company user';

END IF;

-- Update user metadata with company info

  UPDATE auth.users

  SET raw_user_meta_data = jsonb_set(

    COALESCE(raw_user_meta_data,'{}'::jsonb),

'{company_name}',

    to_jsonb(company_name)

);

  UPDATE auth.users

  SET raw_user_meta_data = jsonb_set(

    raw_user_meta_data,

'{company_username}',

    to_jsonb(company_username)

);

  IF company_website ISNOTNULLTHEN

    UPDATE auth.users

    SET raw_user_meta_data = jsonb_set(

    raw_user_meta_data,

'{company_website}',

    to_jsonb(company_website)

);

END IF;

-- Update user type to company

  UPDATE public.user_types

  SET user_type ='company'

WHERE id = auth.uid();

-- Create company and return the ID

SELECT id INTO new_company_id

FROM public.companies

WHERE created_by = auth.uid();

  RETURN new_company_id;

END;

$$
LANGUAGE plpgsql;


-- Set up Storage for avatar and logo uploads

INSERT INTO storage.buckets (id, name, public)

VALUES ('avatars','avatars',true)

ON CONFLICT DO NOTHING;


INSERT INTO storage.buckets (id, name, public)

VALUES ('company_logos','company_logos',true)

ON CONFLICT DO NOTHING;


-- Create policies for storage

CREATE POLICY "Anyone can view avatars" ON storage.objects

FORSELECTUSING(bucket_id ='avatars');


CREATE POLICY "Authenticated users can upload avatars" ON storage.objects

FOR INSERT WITHCHECK(

    bucket_id ='avatars'AND

    auth.role()='authenticated'

);


CREATE POLICY "Users can update their own avatar" ON storage.objects

FOR UPDATE USING(

    bucket_id ='avatars'AND

    auth.uid()::text =(storage.foldername(name))[1]

);


CREATE POLICY "Anyone can view company logos" ON storage.objects

FORSELECTUSING(bucket_id ='company_logos');


CREATE POLICY "Company owners and admins can upload logos" ON storage.objects

FOR INSERT WITHCHECK(

    bucket_id ='company_logos'AND

    auth.role()='authenticated'

);


CREATE POLICY "Company owners and admins can update logos" ON storage.objects

FOR UPDATE USING(

    bucket_id ='company_logos'AND

    EXISTS (

SELECT1FROM public.companies

WHERE id::text =(storage.foldername(name))[1]

AND authorize_company('company.edit', id, auth.uid())

)

);
$$



-- 1. First, let's disable the existing trigger that's automatically creating personal accounts

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

DROP FUNCTION IF EXISTS public.handle_new_google_user();

-- 2. Create a new function that will be called manually from our server code

CREATEOR REPLACE FUNCTION public.set_user_type(

  user_id UUID,

  account_type TEXT

)

RETURNS void

LANGUAGE plpgsql

SECURITY DEFINER

SET search_path = public

AS$$

BEGIN

-- Insert or update the user type in user_types table

  INSERT INTO public.user_types (id, user_type)

  VALUES (user_id, account_type)

ON CONFLICT (id)DO UPDATE

  SET user_type = EXCLUDED.user_type;

-- If it's a personal account, also create a personal profile if it doesn't exist

  IF account_type ='personal'THEN

    INSERT INTO public.personal_profiles (

    id,

    email,

    full_name,

    avatar_url

)

SELECT

    au.id,

    au.email,

    au.raw_user_meta_data->>'full_name',

    au.raw_user_meta_data->>'avatar_url'

FROM auth.users au

WHERE au.id = user_id

ON CONFLICT (id)DO NOTHING;

END IF;

END;

$$
;


-- 3. Create a function to check if a user exists and what type they are

CREATEOR REPLACE FUNCTION public.get_user_type(

  user_id UUID

)

RETURNS TEXT

LANGUAGE plpgsql

SECURITY DEFINER

SET search_path = public

AS
$$

DECLARE

  user_type TEXT;

BEGIN

SELECT ut.user_type INTO user_type

FROM public.user_types ut

WHERE ut.id = user_id;

  RETURN user_type;

END;

$$
;


-- 4. Create a function to create a company and make the user an owner

CREATEOR REPLACE FUNCTION public.setup_company_user(

  user_id UUID,

  company_name TEXT,

  company_username TEXT,

  website TEXT DEFAULTNULL

)

RETURNS BIGINT

LANGUAGE plpgsql

SECURITY DEFINER

SET search_path = public

AS
$$

DECLARE

  new_company_id BIGINT;

BEGIN

-- Create company

  INSERT INTO public.companies (

    username,

    company_name,

    description,

    website,

    created_by

)

  VALUES (

    company_username,

    company_name,

NULL,

    website,

    user_id

)

RETURNING id INTO new_company_id;

-- Make user an owner of the company

  INSERT INTO public.company_members (

    company_id,

    user_id,

    role,

    joined_at

)

  VALUES (

    new_company_id,

    user_id,

'owner',

    NOW()

);

  RETURN new_company_id;

END;

$$
;
$$



-- Check if the trigger exists

SELECT EXISTS (

SELECT1

FROM pg_trigger

WHERE tgname ='on_auth_user_created_check_invitations'

)AS trigger_exists;

-- If it doesn't, recreate it:

DROP TRIGGER IF EXISTS on_auth_user_created_check_invitations ON auth.users;

CREATE TRIGGER on_auth_user_created_check_invitations

  AFTER INSERT ON auth.users

FOR EACH ROW EXECUTE FUNCTION public.handle_company_invitation();




-- Drop the function if it exists

DROP FUNCTION IF EXISTS public.invite_to_company(BIGINT, TEXT, company_role);

-- Create the function again

CREATEOR REPLACE FUNCTION public.invite_to_company(

  in_company_id BIGINT,

  in_email TEXT,

  in_role company_role DEFAULT'member'::public.company_role

)

RETURNS TEXT

SECURITY DEFINER SET search_path = public

AS$$

DECLARE

  token TEXT;

BEGIN

-- Check if the user has permission to invite

  IF NOT authorize_company('member.invite', in_company_id, auth.uid())THEN

    RAISE EXCEPTION 'You do not have permission to invite members to this company';

END IF;

-- Generate a token using gen_random_uuid which is built into PostgreSQL

  token := replace(gen_random_uuid()::text,'-','')|| to_char(now(),'YYYYMMDDHH24MISS');

-- Create the invitation

  INSERT INTO public.company_invitations (

    company_id,

    email,

    role,

    token,

    invited_by

) VALUES (

    in_company_id,

    in_email,

    in_role,

    token,

    auth.uid()

)ON CONFLICT (company_id, email)

DO UPDATE SET

    role = EXCLUDED.role,

    token = EXCLUDED.token,

    invited_by = EXCLUDED.invited_by,

    created_at = now(),

    expires_at = now()+ interval '7 days';

  RETURN token;

END;

$$
LANGUAGE plpgsql;
$$


-- Drop the function if it exists

DROP FUNCTION IF EXISTS public.accept_company_invitation(TEXT);

-- Create the function again with improved error handling and clarity

CREATEOR REPLACE FUNCTION public.accept_company_invitation(invite_token TEXT)

RETURNS BOOLEAN

SECURITY DEFINER SET search_path = public

AS$$

DECLARE

  invitation RECORD;

  user_id UUID;

BEGIN

-- Get the current user's ID

  user_id := auth.uid();

-- Return false if no user is authenticated

  IF user_id ISNULLTHEN

    RAISE EXCEPTION 'You must be logged in to accept an invitation';

END IF;

-- Find the invitation by token (using trim to ensure no whitespace issues)

-- Using table alias 'ci' to avoid ambiguous column references

SELECT ci.*INTO invitation

FROM public.company_invitations ci

WHERE TRIM(ci.token)= TRIM(invite_token)

AND ci.expires_at > now();

-- Check if invitation exists and is valid

  IF invitation ISNULLTHEN

-- Try case-insensitive search as fallback

SELECT ci.*INTO invitation

FROM public.company_invitations ci

WHERE LOWER(TRIM(ci.token))= LOWER(TRIM(invite_token))

AND ci.expires_at > now();

-- If still null, raise exception

    IF invitation ISNULLTHEN

    RAISE EXCEPTION 'Invalid or expired invitation token';

END IF;

END IF;

-- Check if the user is already a member of this company

-- Using table alias 'cm' to avoid ambiguous column references

  IF EXISTS (

SELECT1FROM public.company_members cm

WHERE cm.company_id = invitation.company_id

AND cm.user_id = user_id

)THEN

-- User is already a member, just update their role if the invitation offers a higher role

    UPDATE public.company_members cm

    SET role = invitation.role

WHERE cm.company_id = invitation.company_id

AND cm.user_id = user_id

AND(

-- Only upgrade role, never downgrade

(cm.role ='member'AND invitation.role IN('social','hr','admin','owner'))OR

(cm.role ='social'AND invitation.role IN('hr','admin','owner'))OR

(cm.role ='hr'AND invitation.role IN('admin','owner'))OR

(cm.role ='admin'AND invitation.role IN('owner'))

);

-- Delete the invitation since it's no longer needed

    DELETE FROM public.company_invitations

WHERE id = invitation.id;

    RETURN TRUE;

END IF;

-- Add the user to the company with the invited role

  INSERT INTO public.company_members (

    company_id,

    user_id,

    role,

    invited_by,

    invited_at,

    joined_at

) VALUES (

    invitation.company_id,

    user_id,

    invitation.role,

    invitation.invited_by,

    invitation.created_at,

    now()

);

-- Delete the invitation since it's been used

  DELETE FROM public.company_invitations

WHERE id = invitation.id;

-- Update user type to 'company' if it's currently 'personal'

-- Using table alias 'ut' to avoid ambiguous column references

  UPDATE public.user_types ut

  SET user_type ='company'

WHERE ut.id = user_id

AND ut.user_type ='personal';

  RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN

-- Log the error for debugging

    RAISE LOG 'Error accepting invitation: %', SQLERRM;

    RETURN FALSE;

END;

$$
LANGUAGE plpgsql;
$$
